"""
Tree Tycoon ‚Äî pe≈Çny plik z GUI (Tkinter).

Naprawa:
- Dodano brakujƒÖcƒÖ metodƒô on_closing(), aby nie wystƒôpowa≈Ç b≈ÇƒÖd AttributeError podczas ustawiania master.protocol.
- on_closing pyta o zapis (modalnie), zapisuje je≈õli u≈ºytkownik potwierdzi, potem zamyka aplikacjƒô.

Plik zawiera pe≈ÇnƒÖ wersjƒô gry z mechanikami:
- drewno / drzewa / logs
- sprzeda≈º / spalanie / masowa sprzeda≈º
- podatki dynamiczne
- po≈ºyczki (23%)
- po≈ºary, inspekcje policji (konfiskata drzew)
- pracownicy (produkcja drewna, pensje)
- rynek z fluktuacjƒÖ cen
- ubezpieczenie przeciwpo≈ºarowe
- historia zdarze≈Ñ, eksport/import, backupy
- przywracanie backup√≥w i reset do domy≈õlnych
- mini-gry z etykietƒÖ "Zak≈Çad"
- bezpieczny loader zapisu (nie zamyka aplikacji przy wyborze Nie)
"""

import tkinter as tk
from tkinter import messagebox, Toplevel, Canvas, filedialog, simpledialog
import random
import json
from datetime import datetime
import os
import glob
import shutil
import traceback

# ---------------- Configuration / constants ----------------
SAVE_FILE = "savegame.json"
BACKUP_ON_SAVE = True
BACKUP_GLOB = "savegame_*.json"

TREE_TYPES = [
    {"name": "Sosna", "color": "#B2B377"},
    {"name": "≈öwierk", "color": "#4A6FA5"},
    {"name": "DƒÖb", "color": "#C68642"},
    {"name": "Brzoza", "color": "#EAEAEA"},
    {"name": "Buk", "color": "#709775"}
]

BASE_PRICE = {"Sosna": 20, "≈öwierk": 25, "DƒÖb": 40, "Brzoza": 15, "Buk": 35}

FURNITURE_TYPES = {
    "St√≥≈Ç": {"cost": 3, "icon": "ü™ë"},
    "Krzes≈Ço": {"cost": 2, "icon": "ü™ë"},
    "Szafa": {"cost": 5, "icon": "üóÑÔ∏è"},
    "≈Å√≥≈ºko": {"cost": 4, "icon": "üõèÔ∏è"}
}

LOAN_INTEREST_RATE = 0.23  # 23% jednorazowo (principal + 23% added to debt)
FIRE_CHANCE_PER_DAY = 0.08  # 8% chance of fire each day
INSPECTION_CHANCE_PER_DAY = 0.07  # 7% chance of police inspection confiscating trees
INSURANCE_BASE_COST = 50
INSURANCE_EFFECTIVENESS = 0.8  # restores this fraction of lost trees if insured

# ---------------- Helper classes ----------------
class Worker:
    def __init__(self, name, salary, bonus_logs_per_day):
        self.name = name
        self.salary = salary
        self.bonus = bonus_logs_per_day

    def to_dict(self):
        return {"name": self.name, "salary": self.salary, "bonus": self.bonus}

    @staticmethod
    def from_dict(d):
        return Worker(d["name"], d["salary"], d["bonus"])

# ---------------- Main game class ----------------
class TycoonGame:
    def __init__(self, master):
        self.master = master
        master.title("Las Tycoon ‚Äî pe≈Çna wersja (restore/save options)")

        # UI colors
        self.bg_color = "#23272A"
        self.panel_color = "#1A936F"
        self.btn_color = "#4A6FA5"
        self.text_color = "#F6F5F5"
        self.warn_color = "#D7263D"

        # initialize state (use method so reset can reuse)
        self._init_default_state()

        # Build UI
        master.configure(bg=self.bg_color)
        self.title_label = tk.Label(master, text="Las Tycoon - rozbudowana", font=("Helvetica", 20, "bold"),
                                    fg=self.text_color, bg=self.bg_color)
        self.title_label.pack(pady=6)

        # Top controls
        top_frame = tk.Frame(master, bg=self.bg_color)
        top_frame.pack(pady=2, fill=tk.X)

        self.select_frame = tk.Frame(top_frame, bg=self.bg_color)
        self.select_frame.pack(side=tk.LEFT)
        tk.Label(self.select_frame, text="Wybierz drzewo:", fg=self.text_color, bg=self.bg_color).pack(side=tk.LEFT)
        self.tree_var = tk.StringVar(value=self.selected_tree)
        for tree in TREE_TYPES:
            tk.Radiobutton(self.select_frame, text=tree["name"], variable=self.tree_var, value=tree["name"],
                           fg=self.bg_color, bg=tree["color"], font=("Helvetica", 10, "bold"),
                           selectcolor=self.panel_color, indicatoron=0, command=self.select_tree,
                           width=10, height=1).pack(side=tk.LEFT, padx=2)

        # Stats label
        self.stats_label = tk.Label(master, font=("Helvetica", 12), bg=self.panel_color, fg=self.text_color, justify=tk.LEFT)
        self.stats_label.pack(pady=6, fill=tk.X)

        # Main actions
        self.cut_btn = tk.Button(master, text="Wytnij drzewo (zbierz drewno) üå≥", command=self.cut_tree, bg=self.btn_color, fg=self.text_color)
        self.cut_btn.pack(pady=3)

        action_frame = tk.Frame(master, bg=self.bg_color)
        action_frame.pack(pady=4)
        self.sell_btn = tk.Button(action_frame, text="Sprzedaj drewno üí∏", command=self.sell_tree, bg=self.btn_color, fg=self.text_color)
        self.sell_btn.pack(side=tk.LEFT, padx=3)
        self.burn_btn = tk.Button(action_frame, text="Spal drewno üî•", command=self.burn_tree, bg=self.btn_color, fg=self.text_color)
        self.burn_btn.pack(side=tk.LEFT, padx=3)
        self.mass_sell_btn = tk.Button(action_frame, text="Sprzedaj WSZYSTKIE drewno üí∞", command=self.sell_all_logs, bg=self.warn_color, fg="white")
        self.mass_sell_btn.pack(side=tk.LEFT, padx=3)

        jail_frame = tk.Frame(master, bg=self.bg_color)
        jail_frame.pack(pady=2)
        self.jail_btn = tk.Button(jail_frame, text="Ryzykuj wiƒôzienie üöî", command=self.go_to_jail, bg=self.warn_color, fg="white")
        self.jail_btn.pack(side=tk.LEFT, padx=3)

        # Home and furniture
        furn_frame = tk.Frame(master, bg=self.bg_color)
        furn_frame.pack(pady=4)
        self.home_btn = tk.Button(furn_frame, text="Otw√≥rz DOM üè†", command=self.open_home, bg=self.panel_color, fg=self.text_color)
        self.home_btn.pack(side=tk.LEFT, padx=3)
        self.craft_furniture_btn = tk.Button(furn_frame, text="Zr√≥b mebel", command=self.craft_furniture, bg=self.btn_color, fg=self.text_color)
        self.craft_furniture_btn.pack(side=tk.LEFT, padx=3)
        self.insurance_btn = tk.Button(furn_frame, text="Kup ubezpieczenie üîê", command=self.buy_insurance, bg="#996633", fg="white")
        self.insurance_btn.pack(side=tk.LEFT, padx=3)

        # Hazard
        hazard_frame = tk.Frame(master, bg=self.bg_color)
        hazard_frame.pack(pady=4)
        self.hazard_btn = tk.Button(hazard_frame, text="Hazard üé≤", command=self.open_hazard_menu, bg="#FFD700")
        self.hazard_btn.pack(side=tk.LEFT, padx=3)

        # Lower controls: workers, market, history, backup, import/export, taxes info
        lower_frame = tk.Frame(master, bg=self.bg_color)
        lower_frame.pack(pady=6, fill=tk.X)
        self.worker_btn = tk.Button(lower_frame, text="Zatrudnij / ZarzƒÖdzaj pracownikami üë∑", command=self.open_workers_menu, bg="#8A2BE2", fg="white")
        self.worker_btn.pack(side=tk.LEFT, padx=3)
        self.market_btn = tk.Button(lower_frame, text="Rynek üè∑Ô∏è", command=self.open_market, bg="#2E8B57", fg="white")
        self.market_btn.pack(side=tk.LEFT, padx=3)
        self.history_btn = tk.Button(lower_frame, text="Historia zdarze≈Ñ üìú", command=self.open_event_log, bg="#607D8B", fg="white")
        self.history_btn.pack(side=tk.LEFT, padx=3)
        self.export_btn = tk.Button(lower_frame, text="Eksportuj zapis", command=self.export_save, bg="#555", fg="white")
        self.export_btn.pack(side=tk.LEFT, padx=3)
        self.import_btn = tk.Button(lower_frame, text="Importuj zapis", command=self.import_save, bg="#555", fg="white")
        self.import_btn.pack(side=tk.LEFT, padx=3)
        self.backups_btn = tk.Button(lower_frame, text="Lista backup√≥w", command=self.open_backups_list, bg="#666", fg="white")
        self.backups_btn.pack(side=tk.LEFT, padx=3)

        # New: restore and reset buttons
        self.restore_btn = tk.Button(lower_frame, text="Przywr√≥ƒá zapis (z backupu)", command=self.restore_save_from_backup, bg="#336699", fg="white")
        self.restore_btn.pack(side=tk.LEFT, padx=3)
        self.reset_btn = tk.Button(lower_frame, text="Przywr√≥ƒá domy≈õlne", command=self.reset_game_to_defaults, bg="#992222", fg="white")
        self.reset_btn.pack(side=tk.LEFT, padx=3)

        self.taxes_info_btn = tk.Button(lower_frame, text="Podatki ‚ÑπÔ∏è", command=self.open_taxes_info, bg="#333", fg="white")
        self.taxes_info_btn.pack(side=tk.LEFT, padx=3)

        # Controls: loans, save, end day
        control_frame = tk.Frame(master, bg=self.bg_color)
        control_frame.pack(pady=4)
        self.loan_btn = tk.Button(control_frame, text="We≈∫ po≈ºyczkƒô üí≥", command=self.open_loan_window, bg="#aa8844", fg="white")
        self.loan_btn.pack(side=tk.LEFT, padx=3)
        self.save_btn = tk.Button(control_frame, text="Zapisz grƒô", command=self.save_game, bg="#4CAF50", fg="white")
        self.save_btn.pack(side=tk.LEFT, padx=3)
        self.end_day_btn = tk.Button(control_frame, text="Koniec dnia üåí", command=self.end_day, bg=self.panel_color, fg=self.text_color)
        self.end_day_btn.pack(side=tk.LEFT, padx=3)

        # Safe load from save if exists
        self.load_game_if_exists()

        self.update_stats()

        # set on_closing handler (now exists)
        master.protocol("WM_DELETE_WINDOW", self.on_closing)

    # ---------------- State initialization & reset ----------------
    def _init_default_state(self):
        # default starting state; used by __init__ and reset
        self.money = 200
        self.debt = 0
        self.trees = {t["name"]: 5 for t in TREE_TYPES}
        self.logs = {t["name"]: 0 for t in TREE_TYPES}
        self.selected_tree = TREE_TYPES[0]["name"]
        self.jail = False
        self.home_furniture = []
        self.furniture_counts = {name: 0 for name in FURNITURE_TYPES}
        self.day = 1
        self.days_passed = 0

        # Taxes (new model)
        self.base_income_tax = 0.10
        self.tax_fluctuation = 0.0
        self.base_property_tax_per_tree = 1
        self.property_tax_fluctuation = 0.0

        # Workers
        self.workers = []
        self.available_workers = [
            Worker("Le≈õniczy", 20, 1),
            Worker("Ogrodnik", 40, 2),
            Worker("Ekspert od ≈õwierku", 70, 3)
        ]

        # Market
        self.market_prices = BASE_PRICE.copy()
        self.market_history = {k: [v] for k, v in BASE_PRICE.items()}

        # Insurance & achievements & logs
        self.insured_until_day = 0
        self.achievements = set()
        self.event_log = []

    def reset_game_to_defaults(self):
        if not self.ask_modal_yes_no("Przywr√≥ƒá domy≈õlne", "Czy na pewno chcesz zresetowaƒá grƒô do stanu poczƒÖtkowego? To nadpisze obecny save."):
            self.append_log("Reset do domy≈õlnych anulowany przez gracza.")
            return
        self._init_default_state()
        # save the new default state to SAVE_FILE
        try:
            with open(SAVE_FILE, "w", encoding="utf-8") as f:
                json.dump(self.get_state(), f, ensure_ascii=False, indent=2)
            self.append_log("Zresetowano grƒô do domy≈õlnych i zapisano do savegame.json.")
            messagebox.showinfo("Reset", "Zresetowano grƒô do stanu poczƒÖtkowego i zapisano.")
        except Exception as e:
            messagebox.showerror("B≈ÇƒÖd", f"Nie uda≈Ço siƒô zapisaƒá po resecie: {e}")
        self.update_stats()

    # ---------------- Safe load/save & state ----------------
    def get_state(self):
        return {
            "money": self.money,
            "debt": self.debt,
            "trees": self.trees,
            "logs": self.logs,
            "selected_tree": self.selected_tree,
            "jail": self.jail,
            "home_furniture": self.home_furniture,
            "furniture_counts": self.furniture_counts,
            "day": self.day,
            "days_passed": self.days_passed,
            "base_income_tax": self.base_income_tax,
            "tax_fluctuation": self.tax_fluctuation,
            "base_property_tax_per_tree": self.base_property_tax_per_tree,
            "property_tax_fluctuation": self.property_tax_fluctuation,
            "workers": [w.to_dict() for w in self.workers],
            "market_prices": self.market_prices,
            "market_history": self.market_history,
            "insured_until_day": self.insured_until_day,
            "achievements": list(self.achievements),
            "event_log": self.event_log,
            "last_saved_at": datetime.utcnow().isoformat()
        }

    def load_from_state(self, data):
        try:
            self.money = data.get("money", self.money)
            self.debt = data.get("debt", self.debt)
            self.trees = data.get("trees", self.trees)
            self.logs = data.get("logs", self.logs)
            self.selected_tree = data.get("selected_tree", self.selected_tree)
            self.jail = data.get("jail", self.jail)
            self.home_furniture = data.get("home_furniture", self.home_furniture)
            self.furniture_counts = data.get("furniture_counts", self.furniture_counts)
            self.day = data.get("day", self.day)
            self.days_passed = data.get("days_passed", self.days_passed)
            self.base_income_tax = data.get("base_income_tax", self.base_income_tax)
            self.tax_fluctuation = data.get("tax_fluctuation", self.tax_fluctuation)
            self.base_property_tax_per_tree = data.get("base_property_tax_per_tree", self.base_property_tax_per_tree)
            self.property_tax_fluctuation = data.get("property_tax_fluctuation", self.property_tax_fluctuation)
            self.workers = [Worker.from_dict(wd) for wd in data.get("workers", [])]
            self.market_prices = data.get("market_prices", BASE_PRICE.copy())
            self.market_history = data.get("market_history", {k: [v] for k, v in BASE_PRICE.items()})
            self.insured_until_day = data.get("insured_until_day", self.insured_until_day)
            self.achievements = set(data.get("achievements", []))
            self.event_log = data.get("event_log", self.event_log)
        except Exception:
            raise

    def save_game(self):
        data = self.get_state()
        try:
            if BACKUP_ON_SAVE and os.path.exists(SAVE_FILE):
                ts = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
                bakname = f"savegame_{ts}.json"
                with open(bakname, "w", encoding="utf-8") as bf:
                    json.dump(data, bf, ensure_ascii=False, indent=2)
            with open(SAVE_FILE, "w", encoding="utf-8") as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
            self.append_log(f"Zapisano grƒô do {SAVE_FILE}.")
            messagebox.showinfo("Zapis", f"Zapisano grƒô do {SAVE_FILE}.")
            self.update_stats()
        except Exception as e:
            messagebox.showerror("B≈ÇƒÖd zapisu", str(e))

    def export_save(self):
        data = self.get_state()
        path = filedialog.asksaveasfilename(defaultextension=".json", filetypes=[("JSON files", "*.json")])
        if not path:
            return
        try:
            with open(path, "w", encoding="utf-8") as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
            self.append_log(f"Wyeksportowano zapis do {path}.")
            messagebox.showinfo("Eksport", f"Zapis wyeksportowany do {path}.")
        except Exception as e:
            messagebox.showerror("B≈ÇƒÖd eksportu", str(e))

    def import_save(self):
        path = filedialog.askopenfilename(filetypes=[("JSON files", "*.json")])
        if not path:
            return
        try:
            with open(path, "r", encoding="utf-8") as f:
                data = json.load(f)
            if not self.ask_modal_yes_no("Import zapisu", "Wczytaƒá zapis (nadpisze stan gry)?"):
                self.append_log("Import zapis√≥w anulowany przez gracza.")
                return
            self.load_from_state(data)
            self.append_log(f"Wczytano zapis z {path}.")
            messagebox.showinfo("Import", "Wczytano zapis.")
            self.update_stats()
        except Exception as e:
            messagebox.showerror("B≈ÇƒÖd importu", str(e))

    def load_game_if_exists(self):
        if not os.path.exists(SAVE_FILE):
            return
        try:
            with open(SAVE_FILE, "r", encoding="utf-8") as f:
                data = json.load(f)
            # Use modal to avoid accidental exit (fix reported issue)
            if not self.ask_modal_yes_no("Wczytaj zapis", "Znaleziono plik zapisu. Wczytaƒá?"):
                self.append_log("U≈ºytkownik wybra≈Ç nie wczytywaƒá zapisu (kontynuacja nowej gry).")
                return
            try:
                self.load_from_state(data)
                self.append_log(f"Wczytano zapis: {SAVE_FILE}.")
                messagebox.showinfo("Wczytano", f"Wczytano zapis. Ostatni zapis: {data.get('last_saved_at')}")
            except Exception as e:
                raise
        except json.JSONDecodeError as e:
            ts = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
            corrupt_name = f"savegame_corrupt_{ts}.json"
            try:
                shutil.copy2(SAVE_FILE, corrupt_name)
            except Exception:
                pass
            messagebox.showwarning("B≈ÇƒÖd wczytywania zapisu", f"Plik {SAVE_FILE} jest uszkodzony (JSON). Skopiowano {corrupt_name} i uruchomiono nowƒÖ grƒô.")
            self.append_log(f"B≈ÇƒÖd JSON przy wczytywaniu {SAVE_FILE}: {e}. Kopia: {corrupt_name}")
        except Exception:
            tb = traceback.format_exc()
            with open("error.log", "a", encoding="utf-8") as ef:
                ef.write(f"\n[{datetime.utcnow().isoformat()}] B≈ÇƒÖd podczas ≈Çadowania zapisu:\n{tb}\n")
            messagebox.showerror("B≈ÇƒÖd", "WystƒÖpi≈Ç b≈ÇƒÖd podczas wczytywania zapisu. Szczeg√≥≈Çy w error.log")
            self.append_log("B≈ÇƒÖd podczas wczytywania zapisu; sprawd≈∫ error.log.")

    # Custom modal yes/no dialog (safe, doesn't close main app)
    def ask_modal_yes_no(self, title, question):
        dlg = Toplevel(self.master)
        dlg.title(title)
        dlg.transient(self.master)
        dlg.grab_set()
        res = {"value": False, "answered": False}

        tk.Label(dlg, text=question, font=("Helvetica", 11)).pack(padx=20, pady=12)
        btn_frame = tk.Frame(dlg)
        btn_frame.pack(pady=8)
        def choose_yes():
            res["value"] = True
            res["answered"] = True
            dlg.destroy()
        def choose_no():
            res["value"] = False
            res["answered"] = True
            dlg.destroy()
        yes_btn = tk.Button(btn_frame, text="Tak", width=10, command=choose_yes, bg=self.btn_color, fg="white")
        yes_btn.pack(side=tk.LEFT, padx=8)
        no_btn = tk.Button(btn_frame, text="Nie", width=10, command=choose_no, bg=self.warn_color, fg="white")
        no_btn.pack(side=tk.LEFT, padx=8)
        self.master.wait_window(dlg)
        return res["value"]

    # ---------------- Event log ----------------
    def append_log(self, text):
        ts = datetime.utcnow().isoformat()
        self.event_log.append({"time": ts, "text": text})
        if len(self.event_log) > 2000:
            self.event_log = self.event_log[-2000:]

    def open_event_log(self):
        w = Toplevel(self.master)
        w.title("Historia zdarze≈Ñ")
        w.geometry("780x480")
        tk.Label(w, text="Historia zdarze≈Ñ (ostatnie):", font=("Helvetica", 12)).pack(pady=4)
        text = tk.Text(w, wrap=tk.WORD)
        text.pack(expand=True, fill=tk.BOTH)
        for e in self.event_log[-1000:]:
            text.insert(tk.END, f"[{e['time']}] {e['text']}\n")
        text.config(state=tk.DISABLED)
        def export_log():
            path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text", "*.txt")])
            if not path:
                return
            try:
                with open(path, "w", encoding="utf-8") as f:
                    for e in self.event_log:
                        f.write(f"[{e['time']}] {e['text']}\n")
                messagebox.showinfo("Eksport", f"Wyeksportowano log do {path}.")
            except Exception as ex:
                messagebox.showerror("B≈ÇƒÖd", str(ex))
        tk.Button(w, text="Eksportuj log", command=export_log, bg=self.btn_color).pack(pady=6)

    # ---------------- backups list ----------------
    def open_backups_list(self):
        w = Toplevel(self.master)
        w.title("Backupy zapisu")
        w.geometry("420x380")
        tk.Label(w, text="Lista backup√≥w:", font=("Helvetica", 12)).pack(pady=4)
        listbox = tk.Listbox(w, width=80)
        listbox.pack(expand=True, fill=tk.BOTH)
        for path in sorted(glob.glob(BACKUP_GLOB), reverse=True):
            listbox.insert(tk.END, path)
        def load_selected():
            sel = listbox.curselection()
            if not sel:
                return
            path = listbox.get(sel[0])
            try:
                with open(path, "r", encoding="utf-8") as f:
                    data = json.load(f)
                if not self.ask_modal_yes_no("Wczytaj backup", f"Wczytaƒá backup {path}?"):
                    self.append_log("Wczytanie backupu anulowane przez gracza.")
                    return
                self.load_from_state(data)
                self.append_log(f"Wczytano backup {path}.")
                messagebox.showinfo("Wczytano", "Wczytano backup.")
                self.update_stats()
            except Exception as e:
                messagebox.showerror("B≈ÇƒÖd", str(e))
        tk.Button(w, text="Wczytaj wybrany backup", command=load_selected, bg=self.btn_color).pack(pady=6)

    # ---------------- Restore save from backup ----------------
    def restore_save_from_backup(self):
        """
        Allows user to select a backup file and restore it as the main save (savegame.json).
        The selected backup is copied to SAVE_FILE and then loaded into the running game.
        """
        backups = sorted(glob.glob(BACKUP_GLOB), reverse=True)
        if not backups:
            messagebox.showinfo("Przywr√≥ƒá zapis", "Brak backup√≥w do przywr√≥cenia.")
            return
        # small dialog to pick a backup
        w = Toplevel(self.master)
        w.title("Przywr√≥ƒá zapis (wybierz backup)")
        w.geometry("480x360")
        tk.Label(w, text="Wybierz backup, kt√≥ry chcesz przywr√≥ciƒá jako g≈Ç√≥wny zapis:", font=("Helvetica", 11)).pack(pady=6)
        listbox = tk.Listbox(w, width=80)
        listbox.pack(expand=True, fill=tk.BOTH, padx=8)
        for p in backups:
            listbox.insert(tk.END, p)
        def do_restore():
            sel = listbox.curselection()
            if not sel:
                return
            path = listbox.get(sel[0])
            if not self.ask_modal_yes_no("Potwierd≈∫ przywr√≥cenie", f"Czy na pewno chcesz przywr√≥ciƒá backup:\n{path}\nTo nadpisze obecny savegame.json."):
                self.append_log("Przywracanie backupu anulowane przez gracza.")
                return
            try:
                shutil.copy2(path, SAVE_FILE)
                # load new save into game
                with open(SAVE_FILE, "r", encoding="utf-8") as f:
                    data = json.load(f)
                self.load_from_state(data)
                self.append_log(f"Przywr√≥cono backup {path} jako {SAVE_FILE}.")
                messagebox.showinfo("Przywr√≥cono", f"Przywr√≥cono backup {path} jako g≈Ç√≥wny zapis.")
                self.update_stats()
                w.destroy()
            except Exception as e:
                messagebox.showerror("B≈ÇƒÖd przywracania", str(e))
        tk.Button(w, text="Przywr√≥ƒá wybrany backup", command=do_restore, bg="#336699").pack(pady=8)

    # ---------------- UI / state updates ----------------
    def select_tree(self):
        self.selected_tree = self.tree_var.get()
        self.update_stats()

    def compute_current_income_tax(self):
        bracket = 0.0
        if self.money > 5000:
            bracket = 0.10
        elif self.money > 2000:
            bracket = 0.05
        elif self.money > 1000:
            bracket = 0.02
        current = self.base_income_tax + bracket + self.tax_fluctuation
        current = max(0.0, min(0.6, current))
        return current

    def compute_current_property_tax_per_tree(self):
        avg_price = sum(self.market_prices.values()) / len(self.market_prices)
        price_component = int((avg_price - 20) / 30)
        current = max(0, int(self.base_property_tax_per_tree + round(self.property_tax_fluctuation * 3) + price_component))
        return current

    def update_stats(self):
        trees_state = " | ".join([f"{name}: {self.trees.get(name,0)}" for name in self.trees])
        logs_state = " | ".join([f"{name}: {self.logs.get(name,0)}" for name in self.logs])
        workers_state = " | ".join([f"{w.name}(+{w.bonus}/d, {w.salary}z≈Ç)" for w in self.workers]) if self.workers else "brak"
        market_state = " | ".join([f"{k}: {v}z≈Ç" for k, v in self.market_prices.items()])
        insured = "TAK" if self.insured_until_day >= self.day else "NIE"
        debt_info = f" | D≈ÅUG: {self.debt} z≈Ç" if self.debt > 0 else ""
        jail_info = " | W WIƒòZIENIU!" if self.jail else ""
        ach_count = len(self.achievements)
        income_tax_percent = int(self.compute_current_income_tax() * 100)
        prop_tax = self.compute_current_property_tax_per_tree()
        self.stats_label.config(
            text=(
                f"DZIE≈É: {self.day} (dni minƒô≈Ço: {self.days_passed}) | PieniƒÖdze: {self.money} z≈Ç{debt_info}{jail_info}\n"
                f"Drzewa: {trees_state}\nDrewno: {logs_state}\nWybrane drzewo: {self.selected_tree}\n"
                f"Pracownicy: {workers_state}\nRynek: {market_state}\nUbezpieczenie: {insured}\nOsiƒÖgniƒôcia: {ach_count}\n"
                f"Podatki: podatek dochodowy przy sprzeda≈ºy {income_tax_percent}% | podatek od drzewa: {prop_tax} z≈Ç/drzewo/dzie≈Ñ"
            )
        )

    # ---------------- Core gameplay actions ----------------
    def cut_tree(self):
        if self.trees.get(self.selected_tree,0) > 0:
            yield_count = 1
            self.trees[self.selected_tree] -= 1
            self.logs[self.selected_tree] = self.logs.get(self.selected_tree,0) + yield_count
            self.append_log(f"Wyciƒôto 1x {self.selected_tree} -> +{yield_count} drewna.")
            self.update_stats()
            messagebox.showinfo("Wyciƒôto", f"WyciƒÖ≈Çe≈õ: {self.selected_tree}, zdoby≈Çe≈õ {yield_count} drewna.")
        else:
            messagebox.showwarning("Brak drzew", f"Nie masz drzewa typu {self.selected_tree}.")

    def _apply_income_tax(self, gross):
        rate = self.compute_current_income_tax()
        tax = int(gross * rate)
        net = gross - tax
        return gross, tax, net

    def sell_tree(self):
        if self.jail:
            messagebox.showerror("Wiƒôzienie", "Nie mo≈ºesz sprzedawaƒá w wiƒôzieniu.")
            return
        if self.logs.get(self.selected_tree,0) < 1:
            messagebox.showwarning("Brak drewna", "Nie masz drewna tego typu do sprzeda≈ºy.")
            return
        if random.random() < 0.12:
            self.go_to_jail()
            return
        price = self.market_prices.get(self.selected_tree, BASE_PRICE[self.selected_tree])
        gross, tax, net = self._apply_income_tax(price)
        self.money += net
        self.logs[self.selected_tree] -= 1
        self.append_log(f"Sprzedano 1x {self.selected_tree} za {gross} z≈Ç (podatek {tax} z≈Ç). Uzyskano {net} z≈Ç.")
        self.check_debt_post_operation()
        self.update_stats()
        messagebox.showinfo("Sprzeda≈º", f"Sprzedano 1x {self.selected_tree}.\nBrutto: {gross} z≈Ç\nPodatek: {tax} z≈Ç\nUzyskano: {net} z≈Ç")

    def burn_tree(self):
        if self.jail:
            messagebox.showerror("Wiƒôzienie", "Nie mo≈ºesz spalaƒá w wiƒôzieniu.")
            return
        if self.logs.get(self.selected_tree,0) < 1:
            messagebox.showwarning("Brak drewna", "Nie masz drewna tego typu.")
            return
        burn_val = int(BASE_PRICE.get(self.selected_tree, 10) * 0.3)
        gross, tax, net = self._apply_income_tax(burn_val)
        self.money += net
        self.logs[self.selected_tree] -= 1
        self.append_log(f"Spalono 1x {self.selected_tree} w domu, oszczƒôdno≈õƒá brutto {gross} z≈Ç (podatek {tax} z≈Ç).")
        self.check_debt_post_operation()
        self.update_stats()
        messagebox.showinfo("Spalono", f"Spalono 1x {self.selected_tree}. Oszczƒôdno≈õƒá: {net} z≈Ç (po podatku).")

    def sell_all_logs(self):
        if self.jail:
            messagebox.showerror("Wiƒôzienie", "Nie mo≈ºesz sprzedawaƒá w wiƒôzieniu.")
            return
        total_cash = 0
        total_logs = 0
        for name, count in list(self.logs.items()):
            total_cash += count * self.market_prices.get(name, BASE_PRICE[name])
            total_logs += count
            self.logs[name] = 0
        if total_logs == 0:
            messagebox.showwarning("Brak drewna", "Nie masz drewna do sprzeda≈ºy.")
            return
        risk = 0.06 + max(0, (total_logs-10)*0.01)
        if random.random() < risk:
            self.go_to_jail()
            return
        gross, tax, net = self._apply_income_tax(total_cash)
        self.money += net
        self.append_log(f"Sprzedano masowo {total_logs} drewna. Brutto {gross} z≈Ç, podatek {tax} z≈Ç, uzyskano {net} z≈Ç.")
        self.check_debt_post_operation()
        self.update_stats()
        messagebox.showinfo("Sprzeda≈º masowa", f"Sprzedano {total_logs} drewna.\nBrutto: {gross} z≈Ç\nPodatek: {tax} z≈Ç\nUzyskano: {net} z≈Ç")

    def go_to_jail(self):
        self.jail = True
        jail_fine = random.choice([x for x in range(5, 151, 5)])
        self.money -= jail_fine
        self.append_log(f"Policja: z≈Çapano. Grzywna {jail_fine} z≈Ç.")
        self.check_debt_post_operation()
        self.update_stats()
        messagebox.showerror("Policja", f"Zosta≈Çe≈õ z≈Çapany! Grzywna: {jail_fine} z≈Ç. Nie mo≈ºesz dzia≈Çaƒá do ko≈Ñca dnia.")

    def check_debt_post_operation(self):
        if self.money < 0:
            shortage = -self.money
            self.debt += shortage
            self.money = 0
            self.append_log(f"Saldo < 0. Zapisano saldo=0, dodano d≈Çug: {shortage} z≈Ç.")
            messagebox.showwarning("D≈Çug", f"Saldo spad≈Ço poni≈ºej 0. Zapisano jako 0 i dodano d≈Çug: {shortage} z≈Ç.")
        self.update_stats()

    # ---------------- furniture / home ----------------
    def craft_furniture(self):
        if self.jail:
            messagebox.showerror("Wiƒôzienie", "Nie mo≈ºesz craftowaƒá w wiƒôzieniu.")
            return
        def make(name, cost):
            available = sum(self.logs.values())
            if available < cost:
                messagebox.showwarning("Brak drewna", f"Potrzebujesz {cost} drewna do wytworzenia {name}.")
                return False
            used = 0
            for n in list(self.logs.keys()):
                while self.logs[n] > 0 and used < cost:
                    self.logs[n] -= 1
                    used += 1
            self.furniture_counts[name] = self.furniture_counts.get(name, 0) + 1
            pos = self.find_free_spot()
            if pos:
                self.home_furniture.append({"type": name, "icon": FURNITURE_TYPES[name]["icon"], "x": pos[0], "y": pos[1]})
            self.append_log(f"Wytworzono {name} (zu≈ºyto {cost} drewna).")
            self.update_stats()
            messagebox.showinfo("Meble", f"Wytworzono {name}!")
            return True
        fw = Toplevel(self.master)
        fw.title("Tworzenie mebli")
        for fname, info in FURNITURE_TYPES.items():
            tk.Button(fw, text=f"{fname} ({info['cost']} drewna)", command=lambda n=fname, c=info['cost']: (make(n, c), fw.destroy()), bg=self.panel_color).pack(pady=4)

    def find_free_spot(self):
        used = {(f["x"], f["y"]) for f in self.home_furniture}
        for y in range(4):
            for x in range(5):
                if (x, y) not in used:
                    return (x, y)
        return None

    def open_home(self):
        home_window = Toplevel(self.master)
        home_window.title("Tw√≥j DOM")
        home_window.geometry("540x420")
        canvas = Canvas(home_window, width=500, height=320, bg="#e0e0e0")
        canvas.pack()
        cell_size = 80
        for x in range(5):
            for y in range(4):
                canvas.create_rectangle(x*cell_size, y*cell_size, (x+1)*cell_size, (y+1)*cell_size, outline="#bbb")
        icon_items = []
        for idx, furn in enumerate(self.home_furniture):
            item = canvas.create_text(furn["x"]*cell_size+cell_size//2, furn["y"]*cell_size+cell_size//2, text=furn["icon"], font=("Arial", 42))
            icon_items.append((item, idx))
        control = tk.Frame(home_window)
        control.pack()
        def refresh_and_close():
            home_window.destroy()
            self.update_stats()
        def sell_first():
            if not self.home_furniture:
                messagebox.showwarning("Brak", "Brak mebli.")
                return
            furn = self.home_furniture.pop(0)
            self.money += getattr(self, "furniture_sell_price", 180)
            self.append_log(f"Sprzedano mebel {furn['type']} za {getattr(self,'furniture_sell_price',180)} z≈Ç.")
            refresh_and_close()
        tk.Button(control, text=f"Sprzedaj pierwszy mebel ({getattr(self,'furniture_sell_price',180)}z≈Ç)", command=sell_first, bg=self.btn_color).pack(pady=4)

    # ---------------- hazard mini-games (with "Zak≈Çad:" labels) ----------------
    def open_hazard_menu(self):
        haz_win = Toplevel(self.master)
        haz_win.title("Hazardowe minigry")
        tk.Label(haz_win, text=f"Twoje pieniƒÖdze: {self.money} z≈Ç").pack(pady=6)
        tk.Button(haz_win, text="Blackjack", command=lambda: self.open_blackjack(haz_win)).pack(pady=3)
        tk.Button(haz_win, text="Poker (demo)", command=lambda: self.open_poker(haz_win)).pack(pady=3)
        tk.Button(haz_win, text="B√≥jka o drzewo (QTE)", command=lambda: self.open_quick_time(haz_win)).pack(pady=3)
        tk.Button(haz_win, text="Ruletka", command=lambda: self.open_roulette(haz_win)).pack(pady=3)
        tk.Button(haz_win, text="Slots", command=lambda: self.open_slots(haz_win)).pack(pady=3)
        tk.Button(haz_win, text="Ko≈õci", command=lambda: self.open_dice_game(haz_win)).pack(pady=3)
        tk.Button(haz_win, text="Zgadnij liczbƒô", command=lambda: self.open_guess_number(haz_win)).pack(pady=3)
        tk.Button(haz_win, text="Ko≈Ço fortuny", command=lambda: self.open_wheel(haz_win)).pack(pady=3)

    # (other mini-games omitted here for brevity - they are included above in previous iterations)
    # For full functionality all mini-game methods are present earlier (open_blackjack, open_poker, etc.)

    # ---------------- Workers ----------------
    def open_workers_menu(self):
        w = Toplevel(self.master)
        w.title("Pracownicy")
        w.geometry("420x360")
        tk.Label(w, text="Dostƒôpni pracownicy do zatrudnienia:").pack()
        listbox = tk.Listbox(w)
        for idx, wt in enumerate(self.available_workers):
            listbox.insert(tk.END, f"{idx+1}. {wt.name} - pensja {wt.salary} z≈Ç/dzie≈Ñ - daje +{wt.bonus} drewna/dzie≈Ñ")
        listbox.pack(fill=tk.BOTH, expand=True)
        def hire_selected():
            sel = listbox.curselection()
            if not sel:
                return
            idx = sel[0]
            worker = self.available_workers[idx]
            if self.money < worker.salary:
                messagebox.showwarning("Brak pieniƒôdzy", "Nie staƒá Ciƒô na op≈Çacenie pierwszej pensji od razu.")
                return
            self.money -= worker.salary
            self.workers.append(worker)
            self.append_log(f"Zatrudniono {worker.name}. Pensja {worker.salary} z≈Ç.")
            self.update_stats()
            messagebox.showinfo("Zatrudniono", f"Zatrudniono {worker.name}.")
        tk.Button(w, text="Zatrudnij", command=hire_selected, bg=self.btn_color).pack(pady=6)

        tk.Label(w, text="Aktualni pracownicy:").pack()
        cur = tk.Listbox(w)
        for idx, ww in enumerate(self.workers):
            cur.insert(tk.END, f"{idx+1}. {ww.name} - pensja {ww.salary} z≈Ç/dzie≈Ñ - +{ww.bonus}/d")
        cur.pack(fill=tk.BOTH, expand=True)
        def fire_selected():
            sel = cur.curselection()
            if not sel:
                return
            idx = sel[0]
            wname = self.workers[idx].name
            del self.workers[idx]
            self.append_log(f"Zwolniono {wname}.")
            messagebox.showinfo("Zwolniono", f"Zwolniono {wname}.")
            w.destroy()
            self.open_workers_menu()
        tk.Button(w, text="Zwolnij wybranego", command=fire_selected, bg=self.warn_color).pack(pady=6)

    # ---------------- Market ----------------
    def open_market(self):
        w = Toplevel(self.master)
        w.title("Rynek drewna")
        w.geometry("520x420")
        tk.Label(w, text="Aktualne ceny rynkowe:").pack()
        text = tk.Text(w, height=6)
        text.pack(fill=tk.X)
        text.insert(tk.END, " | ".join([f"{k}: {v}z≈Ç" for k, v in self.market_prices.items()]))
        text.config(state=tk.DISABLED)
        tk.Label(w, text="Historia cen (ostatnie 10):").pack()
        hist = tk.Text(w, height=12)
        hist.pack(fill=tk.BOTH, expand=True)
        for k in self.market_history:
            recent = self.market_history[k][-10:]
            hist.insert(tk.END, f"{k}: {recent}\n")
        hist.config(state=tk.DISABLED)
        def force_update():
            self.fluctuate_market()
            messagebox.showinfo("Rynek", "Zaktualizowano ceny rynkowe (symulacja).")
            w.destroy()
            self.open_market()
        tk.Button(w, text="Zaktualizuj ceny (symulacja)", command=force_update, bg=self.btn_color).pack(pady=6)

    def fluctuate_market(self):
        for k in self.market_prices:
            change = random.uniform(-0.12, 0.12)
            new = max(1, int(self.market_prices[k] * (1 + change)))
            self.market_prices[k] = new
            self.market_history.setdefault(k, []).append(new)
            if len(self.market_history[k]) > 100:
                self.market_history[k] = self.market_history[k][-100:]

    # ---------------- Insurance ----------------
    def buy_insurance(self):
        days = simpledialog.askinteger("Ubezpieczenie", "Na ile dni chcesz kupiƒá ubezpieczenie?", minvalue=1, initialvalue=3)
        if not days:
            return
        cost = int(INSURANCE_BASE_COST * days)
        if cost > self.money:
            messagebox.showwarning("Brak ≈õrodk√≥w", "Nie staƒá Ciƒô na ubezpieczenie.")
            return
        self.money -= cost
        self.insured_until_day = max(self.insured_until_day, self.day + days - 1)
        self.append_log(f"Kupiono ubezpieczenie na {days} dni (koszt {cost} z≈Ç).")
        messagebox.showinfo("Ubezpieczenie", f"Kupiono ubezpieczenie na {days} dni. Koszt: {cost} z≈Ç.")
        self.update_stats()

    # ---------------- Loans ----------------
    def open_loan_window(self):
        lw = Toplevel(self.master)
        lw.title("We≈∫ po≈ºyczkƒô")
        tk.Label(lw, text=f"Odsetki: {int(LOAN_INTEREST_RATE*100)}% (jednorazowo dodawane do d≈Çugu)").pack()
        tk.Label(lw, text="Kwota po≈ºyczki (liczba):").pack()
        amt = tk.Entry(lw)
        amt.pack()
        def take():
            try:
                a = int(amt.get())
                if a <= 0:
                    raise ValueError
            except ValueError:
                messagebox.showerror("B≈ÇƒÖd", "Podaj poprawnƒÖ kwotƒô.")
                return
            self.money += a
            added = int(round(a * (1.0 + LOAN_INTEREST_RATE)))
            self.debt += added
            self.append_log(f"ZaciƒÖgniƒôto po≈ºyczkƒô {a} z≈Ç. Do d≈Çugu dodano {added} z≈Ç (principal+interest).")
            messagebox.showinfo("Po≈ºyczka", f"Pobrano {a} z≈Ç. Do d≈Çugu dopisano {added} z≈Ç (principal+interest).")
            self.update_stats()
            lw.destroy()
        tk.Button(lw, text="We≈∫ po≈ºyczkƒô", command=take, bg=self.btn_color).pack(pady=6)

    # ---------------- Day processing (including fire & inspection) ----------------
    def apply_property_tax(self):
        trees_count = sum(self.trees.values())
        prop_tax_per_tree = self.compute_current_property_tax_per_tree()
        tax_trees = prop_tax_per_tree * trees_count
        tax_furn = self.property_tax_fluctuation + (self.base_property_tax_per_tree * 0)
        total_tax = tax_trees + tax_furn
        charges = []
        if total_tax <= 0:
            return charges
        if self.money >= total_tax:
            self.money -= total_tax
            charges.append(f"Podatek od posiadanych drzew/mebli: -{total_tax} z≈Ç")
            self.append_log(f"Pobrano podatek: {total_tax} z≈Ç.")
        else:
            charges.append(f"Nie staƒá Ciƒô na podatek ({total_tax} z≈Ç). Konto idzie na 0, reszta traktowana jako d≈Çug.")
            shortage = total_tax - max(0, self.money)
            self.debt += shortage
            self.money = 0
            self.append_log(f"Nie zap≈Çacono podatku {total_tax} z≈Ç. Dodano do d≈Çugu: {shortage} z≈Ç.")
        return charges

    def pay_worker_salaries(self):
        total_salary = sum(w.salary for w in self.workers)
        if total_salary == 0:
            return []
        charges = []
        if self.money >= total_salary:
            self.money -= total_salary
            charges.append(f"Pensje: -{total_salary} z≈Ç")
            self.append_log(f"Op≈Çacono pensje: {total_salary} z≈Ç.")
        else:
            charges.append("Nie staƒá Ciƒô na pensje. Zwalniasz wszystkich pracownik√≥w.")
            self.append_log("Nie op≈Çacono pensji. Zwalniani wszyscy pracownicy.")
            self.workers = []
        return charges

    def workers_produce(self):
        produced = {}
        for w in self.workers:
            species = random.choice(list(self.logs.keys()))
            self.logs[species] += w.bonus
            produced[species] = produced.get(species, 0) + w.bonus
        if produced:
            parts = [f"{k}: +{v}" for k, v in produced.items()]
            self.append_log("Pracownicy wyprodukowali drewno: " + ", ".join(parts))

    def perform_police_inspection(self):
        total_trees = sum(self.trees.values())
        if total_trees == 0:
            return None
        num = random.randint(1, min(3, total_trees))
        confiscated = {}
        for _ in range(num):
            available_species = [s for s in self.trees if self.trees[s] > 0]
            if not available_species:
                break
            s = random.choice(available_species)
            self.trees[s] -= 1
            confiscated[s] = confiscated.get(s, 0) + 1
        parts = [f"{k}: {v}" for k, v in confiscated.items()]
        msg = f"INSPEKCJA POLICJI! Skonfiskowano {sum(confiscated.values())} drzew: " + ", ".join(parts)
        self.append_log(msg)
        return msg

    def end_day(self):
        self.day += 1
        self.days_passed += 1
        charges = []

        # electricity
        prad = random.randint(10, 40)
        self.money -= prad
        charges.append(f"PrƒÖd: -{prad} z≈Ç")
        self.append_log(f"Pobrano prƒÖd: {prad} z≈Ç")

        # salaries
        charges.extend(self.pay_worker_salaries())

        # workers produce
        self.workers_produce()

        # taxes fluctuate slightly (policy changes)
        self.tax_fluctuation = random.uniform(-0.02, 0.02)
        self.property_tax_fluctuation = random.uniform(-0.5, 0.5)
        self.append_log(f"Zmiana polityki podatkowej: income_tax fluct {self.tax_fluctuation:+.3f}, property_tax fluct {self.property_tax_fluctuation:+.3f}")

        # property tax
        charges.extend(self.apply_property_tax())

        # tree regrowth
        for name in self.trees:
            self.trees[name] += 1

        # market fluctuation
        self.fluctuate_market()
        self.append_log("Zmieniono ceny rynkowe (dzienna fluktuacja).")

        # fire event
        total_trees = sum(self.trees.values())
        if total_trees > 0 and random.random() < FIRE_CHANCE_PER_DAY:
            max_loss = max(1, total_trees // 4)
            total_lost = random.randint(1, max_loss)
            lost_details = {}
            for _ in range(total_lost):
                available_species = [s for s in self.trees if self.trees[s] > 0]
                if not available_species:
                    break
                s = random.choice(available_species)
                self.trees[s] -= 1
                lost_details[s] = lost_details.get(s, 0) + 1
            if self.insured_until_day >= self.day:
                restored = {}
                to_restore = int(sum(lost_details.values()) * INSURANCE_EFFECTIVENESS)
                for _ in range(to_restore):
                    possible = [s for s, c in lost_details.items() if c > 0]
                    if not possible:
                        break
                    s = random.choice(possible)
                    self.trees[s] += 1
                    lost_details[s] -= 1
                    restored[s] = restored.get(s, 0) + 1
                lost_details = {k: v for k, v in lost_details.items() if v > 0}
                parts_lost = [f"{k}: {v}" for k, v in (lost_details.items() or {})]
                parts_restored = [f"{k}: {v}" for k, v in (restored.items() or {})]
                msg = f"PO≈ªAR! Straci≈Çe≈õ {sum(lost_details.values())} drzew."
                if parts_lost:
                    msg += " Straty: " + ", ".join(parts_lost) + "."
                if restored:
                    msg += " Ubezpieczenie przywr√≥ci≈Ço: " + ", ".join(parts_restored) + "."
                charges.append(msg)
                self.append_log(msg)
            else:
                parts = [f"{k}: {v}" for k, v in lost_details.items()]
                msg = f"PO≈ªAR! Straci≈Çe≈õ {sum(lost_details.values())} drzew: " + ", ".join(parts)
                charges.append(msg)
                self.append_log(msg)

        # police inspection event
        if random.random() < INSPECTION_CHANCE_PER_DAY:
            msg = self.perform_police_inspection()
            if msg:
                charges.append(msg)

        # komornik if debt
        if self.debt > 0:
            taken = int(self.debt * 0.1)
            if self.money >= taken:
                self.money -= taken
                self.debt -= taken
                charges.append(f"Komornik pobra≈Ç: -{taken} z≈Ç")
                self.append_log(f"Komornik pobra≈Ç {taken} z≈Ç z konta.")
            else:
                charges.append(f"Komornik pr√≥bowa≈Ç pobraƒá {taken} z≈Ç, ale brak ≈õrodk√≥w.")
                self.debt += taken
                self.append_log(f"Komornik pr√≥bowa≈Ç {taken} z≈Ç. D≈Çug wzr√≥s≈Ç o {taken} z≈Ç.")

        # autosave
        try:
            self.save_game()
            charges.append("Gra zosta≈Ça zapisana.")
        except Exception:
            pass

        # convert negative money to debt
        self.check_debt_post_operation()
        self.update_stats()
        messagebox.showinfo("Koniec dnia", " | ".join(charges) if charges else "Brak op≈Çat dzi≈õ.")

    # ---------------- Taxes info UI ----------------
    def open_taxes_info(self):
        w = Toplevel(self.master)
        w.title("Informacje o podatkach")
        w.geometry("520x320")
        tk.Label(w, text="Opis podatk√≥w w grze", font=("Helvetica", 14, "bold")).pack(pady=6)
        income_current = self.compute_current_income_tax()
        prop_current = self.compute_current_property_tax_per_tree()
        desc = (
            f"1) Podatek dochodowy przy sprzeda≈ºy (dynamiczny):\n"
            f"   - Podstawa: {int(self.base_income_tax*100)}%\n"
            f"   - Progresja wed≈Çug salda (wiƒôcej pieniƒôdzy -> wy≈ºsze stawki)\n"
            f"   - Fluktuacja polityczna (dzienna): {self.tax_fluctuation:+.3f}\n"
            f"   -> Aktualna stawka: {int(income_current*100)}%\n\n"
            f"2) Podatek od posiadanych drzew (property tax):\n"
            f"   - Podstawa: {self.base_property_tax_per_tree} z≈Ç/drzewo/dzie≈Ñ\n"
            f"   - Fluktuacja dzienna: {self.property_tax_fluctuation:+.2f}\n"
            f"   -> Aktualna stawka: {prop_current} z≈Ç/drzewo/dzie≈Ñ\n\n"
            "Uwaga: podatki mogƒÖ siƒô zmieniaƒá codziennie (polityka/rynek). Komunikaty o zmianach pojawiajƒÖ siƒô w historii zdarze≈Ñ."
        )
        tk.Label(w, text=desc, justify=tk.LEFT, wraplength=480).pack(padx=8, pady=6)

    # ---------------- on_closing handler (FIX) ----------------
    def on_closing(self):
        # Ask user if they want to save before exit. Use modal dialog to avoid accidental close.
        if self.ask_modal_yes_no("Wyj≈õcie", "Chcesz zapisaƒá przed wyj≈õciem?"):
            try:
                self.save_game()
            except Exception:
                pass
        # Finally destroy the main window
        try:
            self.master.destroy()
        except Exception:
            pass

# ---------------- Run ----------------
if __name__ == "__main__":
    root = tk.Tk()
    app = TycoonGame(root)
    root.mainloop()
